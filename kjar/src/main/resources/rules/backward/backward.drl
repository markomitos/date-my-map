package backward;

import com.ftn.sbnz.model.models.QuestionNode;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.stream.Collectors;
import com.ftn.sbnz.model.models.FinalPath;
import com.ftn.sbnz.model.models.FindPathForYear;

declare PathResult
    questionId: String
    text: String
    answer: String
end

query isParent(QuestionNode $parent, QuestionNode $child)
    QuestionNode(
        this == $parent,
        ( nextQuestionIdOnYes == $child.id || nextQuestionIdOnNo == $child.id )
    )
    or
    (
        $intermediateNode: QuestionNode() and
        QuestionNode(
            this == $parent,
            ( nextQuestionIdOnYes == $intermediateNode.id || nextQuestionIdOnNo == $intermediateNode.id )
        ) and
        isParent( $intermediateNode, $child; )
    )
end


query "Get Final Path"
    $fp: FinalPath()
end


rule "Find Starting Leaf Node"
    salience 10
    when
        $goal: FindPathForYear($year: year)
        $node: QuestionNode(
            ( (nextQuestionIdOnYes.startsWith("P") && Integer.parseInt(nextQuestionIdOnYes.substring(1, 5)) <= $year && Integer.parseInt(nextQuestionIdOnYes.substring(6, 10)) >= $year) ||
              (nextQuestionIdOnNo.startsWith("P") && Integer.parseInt(nextQuestionIdOnNo.substring(1, 5)) <= $year && Integer.parseInt(nextQuestionIdOnNo.substring(6, 10)) >= $year) )
        )
    then
        String answer_period = ($node.getNextQuestionIdOnYes().startsWith("P") && Integer.parseInt($node.getNextQuestionIdOnYes().substring(1, 5)) <= $year && Integer.parseInt($node.getNextQuestionIdOnYes().substring(6, 10)) >= $year)
                        ? "Yes"
                        : "No";
        insert(new PathResult($node.getId(), $node.getText(), answer_period));
        delete($goal);
end

rule "Build Path Using Query"
    salience 5
    when
        $leafResult: PathResult()
        $leafNode: QuestionNode(id == $leafResult.questionId)
        $ancestor: QuestionNode()
        isParent($ancestor, $leafNode;)
        not PathResult(questionId == $ancestor.id)
        $childOnPath: QuestionNode(
            id == $ancestor.nextQuestionIdOnYes || id == $ancestor.nextQuestionIdOnNo
        )
        and (
             eval($childOnPath == $leafNode) or isParent($childOnPath, $leafNode;)
        )
    then
        String answer = $ancestor.getNextQuestionIdOnYes().equals($childOnPath.getId()) ? "Yes" : "No";
        insert(new PathResult($ancestor.getId(), $ancestor.getText(), answer));
end


rule "Accumulate and Sort Path"
    salience -10
    when
        not FindPathForYear()

        $pathList: List() from accumulate(
            PathResult( $q: questionId, $t: text, $a: answer ),
            collectList(new PathResult($q, $t, $a))
        )
    then
        List<PathResult> mutablePathList = new ArrayList<>($pathList);

        List<String> formattedPath = (List<String>) mutablePathList.stream()
            .map(pr -> "On the question '" + ((PathResult)pr).getText() + "', the answer was '" + ((PathResult)pr).getAnswer() + "'")
            .toList();

        insert(new FinalPath(formattedPath));
end